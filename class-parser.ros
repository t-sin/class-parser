#!/bin/sh
#|-*- mode:lisp -*-|#
#|
exec ros -Q -- $0 "$@"
|#
(progn ;;init forms
  (ros:ensure-asdf)
  #+quicklisp (ql:quickload '(:babel) :silent t)
  )

(defpackage :ros.script.class-parser.3733376269
  (:use :cl))
(in-package :ros.script.class-parser.3733376269)

;;;
;;; utilities

(defun read-u4 (stream)
  (let (bytes)
    (dotimes (n 4)
      (push (read-byte stream nil :eof) bytes))
    (nreverse bytes)))

(defun read-u2 (stream)
  (let (bytes)
    (dotimes (n 2)
      (push (read-byte stream nil :eof) bytes))
    (nreverse bytes)))

(defun as-integer (bytes)
  (let ((i 0))
    (dotimes (n (length bytes) i)
      (let ((offset (* n 8)))
        (setf (ldb (byte 8 offset) i) (nth (- (length bytes) n 1) bytes))))))

;;;
;;; read files

(defun read-magic (stream)
  (let ((bytes (read-u4 stream)))
    (values bytes (and (every (lambda (e) (typep e '(unsigned-byte 8))) bytes)
                       (loop
                         :for b1 :in bytes
                         :for b2 :in '(#xCA #xFE #xBA #xBE)
                         :always (= b1 b2))))))

(defun read-version (stream)
  (let ((minor-ver (as-integer (read-u2 stream)))
        (major-ver (as-integer (read-u2 stream))))
    (cons major-ver minor-ver)))


(defun read-constant (stream)
  (let ((tag (read-byte stream)))
    (ecase tag
      (7 (let ((name-index (as-integer (read-u2 stream))))
           (list :const/class name-index)))
      (9 (let ((class-index (as-integer (read-u2 stream)))
               (name-index (as-integer (read-u2 stream))))
           (list :const/field-ref class-index name-index)))
      (10 (let ((class-index (as-integer (read-u2 stream)))
                (name-index (as-integer (read-u2 stream))))
            (list :const/method-ref class-index name-index)))
      (11 (let ((class-index (as-integer (read-u2 stream)))
                (name-index (as-integer (read-u2 stream))))
            (list :const/interface-method-ref class-index name-index)))
      (8 (let ((str-index (as-integer (read-u2 stream))))
           (list :const/string str-index)))
      (3 (let ((num (as-integer (read-u4 stream))))
           (list :const/integer num)))
      (4 (let ((num (as-integer (read-u4 stream))))
           (list :const/float num)))
      (5 (let ((high (as-integer (read-u4 stream)))
               (low (as-integer (read-u4 stream))))
           (list :const/long high low)))
      (6 (let ((high (as-integer (read-u4 stream)))
               (low (as-integer (read-u4 stream))))
           (list :const/double high low)))
      (12 (let ((name-index (as-integer (read-u2 stream)))
                (discripter-index (as-integer (read-u2 stream))))
            (list :const/name-and-type name-index discripter-index)))
      (1 (let* ((len (as-integer (read-u2 stream)))
                (buf (make-array len :element-type '(unsigned-byte 8))))
           (read-sequence buf stream :end len)
           (list :const/utf8 buf (babel:octets-to-string buf :encoding :utf-8))))
      (15 :const/method-handle)
      (16 :const/medhot-type)
      (18 :const/invoke-dynamic))))

(defun read-constant-pool (stream)
  (let ((count (as-integer (read-u2 stream)))
        (constants nil))
    ;; entries of constant-pool are index like this: 0 < i < count
    (dotimes (n (1- count) (nreverse constants))
      (push (read-constant stream) constants))))

(defvar +access-flags+
  '((#x0001 . :acc/public)
    (#x0010 . :acc/final)
    (#x0020 . :acc/super)
    (#x0200 . :acc/interface)
    (#x0400 . :acc/abstract)
    (#x1000 . :acc/synthetic)
    (#x2000 . :acc/annotation)
    (#x4000 . :/acc/enum)))

(defun read-access-flags (stream)
  (let ((flags (as-integer (read-u2 stream)))
        (flag-list))
    (dolist (f (mapcar #'car +access-flags+) (nreverse flag-list))
      (when (not (zerop (logand f flags)))
        (push (cdr (assoc f +access-flags+)) flag-list)))))

(defun read-this/super-class (stream &optional constant-pool)
  (let ((index (as-integer (read-u2 stream))))
    (if constant-pool
        (list index (nth (1- index) constant-pool))
        index)))


(defun read-interface (stream)
  (as-integer (read-u2 stream)))

;;; interfaces implemented on `this` class
(defun read-interfaces (stream)
  (let ((count (as-integer (read-u2 stream)))
        (interfaces nil))
    (dotimes (n count (nreverse interfaces))
      (push (read-interface stream) interfaces))))


(defun read-attributes (stream)
  (let ((name-index (as-integer (read-u2 stream)))
        (len (as-integer (read-u4 stream))))
    (let ((buffer (make-array len)))
      (read-sequence buffer stream)
      (list name-index buffer))))



(defun read-field (stream &optional constant-pool)
  (let* ((acc (read-access-flags stream))
         (name-index (as-integer (read-u2 stream)))
         (desc-index (as-integer (read-u2 stream)))
         (attr-count (as-integer (read-u2 stream)))
         (attributes nil))
    (dotimes (n attr-count)
      (push (read-attributes stream) attributes))
    (list acc
          (if constant-pool
              (nth name-index constant-pool)
              name-index)
          (if constant-pool
              (nth desc-index constant-pool)
              desc-index)
          (nreverse attributes))))

(defun read-fields (stream &optional constant-pool)
  (let ((count (as-integer (read-u2 stream)))
        (fields nil))
    (dotimes (n count (nreverse fields))
      (push (read-field stream constant-pool) fields))))


(defun read-method (stream &optional constant-pool)
  (let* ((acc (read-access-flags stream))
         (name-index (as-integer (read-u2 stream)))
         (desc-index (as-integer (read-u2 stream)))
         (attr-count (as-integer (read-u2 stream)))
         (attributes nil))
    (dotimes (n attr-count)
      (push (read-attributes stream) attributes))
    (list acc
          (if constant-pool
              (nth name-index constant-pool)
              name-index)
          (if constant-pool
              (nth desc-index constant-pool)
              desc-index)
          (nreverse attributes))))

(defun read-methods (stream &optional constant-pool)
  (let ((count (as-integer (read-u2 stream)))
        (methods nil))
    (dotimes (n count (nreverse methods))
      (push (read-method stream constant-pool) methods))))


(defun read-class-file (pathname)
  (with-open-file (in pathname
                      :direction :input
                      :element-type '(unsigned-byte 8))
    (format t "------- ~a -------~%" pathname)
    (multiple-value-bind (magic correct?)
        (read-magic in)
      (if (not correct?)
          (error "invalid magic!")
          (format t "(magic . version): ([~{~x~^ ~}] . ~s)~%"
                  magic (read-version in))))
    (let ((constants nil)
          (interfaces nil)
          (fields nil)
          (methods nil)
          (attrs nil))
      (setf constants (read-constant-pool in))
      (format t "------- constants -------~%~s~%" constants)
      
      (format t "------- this -------~%~s~%~s~%"
              (read-access-flags in)
              (read-this/super-class in constants))
      (format t "------- super -------~%~s~%"
              (read-this/super-class in constants))

      (setf interfaces (read-interfaces in))
      (format t "------- interfaces -------~%~s~%" interfaces)

      (setf fields (read-fields in constants))
      (format t "------- fields -------~%~s~%" fields)

      (setf methods (read-methods in constants))
      (format t "------- methods -------~%~s~%" methods)

      ;; (setf attrs (read-attributes in))
      ;; (format t "------- attributes -------~%~s~%" attrs)

      (format t "~%======== end ========~%")
      (format t "file-potision: ~s~%" (file-position in))
      (format t "file-length: ~s~%" (file-length in)))))


(defun main (&rest argv)
  (declare (ignorable argv))
  (read-class-file (first argv)))
;;; vim: set ft=lisp lisp:
